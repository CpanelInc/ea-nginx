#!/usr/local/cpanel/3rdparty/bin/perl
# cpanel - ea-nginx                                Copyright 2020 cPanel, L.L.C.
#                                                           All rights Reserved.
# copyright@cpanel.net                                         http://cpanel.net
# This code is subject to the cPanel license. Unauthorized copying is prohibited

use strict;
use warnings;

package scripts::ea_nginx;

use Cpanel::Apache::TLS                     ();
use Cpanel::Config::LoadCpConf              ();
use Cpanel::Config::LoadUserDomains         ();
use Cpanel::Config::LoadWwwAcctConf         ();
use Cpanel::Config::userdata                ();
use Cpanel::Config::userdata::PassengerApps ();
use Cpanel::DomainIp                        ();
use Cpanel::DomainLookup::DocRoot           ();
use Cpanel::FileUtils::TouchFile            ();
use Cpanel::HTTP::Client                    ();
use Cpanel::HttpUtils::ApRestart::BgSafe    ();
use Cpanel::Hostname                        ();
use Cpanel::JSON                            ();
use Cpanel::NAT                             ();
use Cpanel::PHP::Config                     ();
use Cpanel::PHPFPM::Get                     ();
use Cpanel::PwCache                         ();
use Cpanel::Rand::Get                       ();
use Cpanel::SafeRun::Object                 ();
use Cpanel::Transaction::File::JSON         ();
use Cpanel::Validate::URL                   ();
use Cpanel::Validate::Username              ();
use File::Glob                              ();
use File::Path::Tiny                        ();
use IO::Callback                            ();
use String::UnicodeUTF8                     ();
use Template                                ();
use Whostmgr::TweakSettings                 ();

use Path::Tiny;
use MCE::Loop;

our $var_cache_ea_nginx                = '/var/cache/ea-nginx';
our $var_cpanel_userdata               = '/var/cpanel/userdata';
our $etc_nginx                         = '/etc/nginx';
our $settings_file                     = '/etc/nginx/ea-nginx/settings.json';
our $cache_file                        = '/etc/nginx/ea-nginx/cache.json';
our $wp_toolkit_bin                    = '/usr/local/bin/wp-toolkit';
our $wordpress_cache_dir               = '/etc/nginx/wordpress_info_cache';
our $disable_wordpress_info_cache_file = '/var/cpanel/nginx_disable_wordpress_info_cache';
our $proxy_header_file                 = '/etc/nginx/ea-nginx/cpanel_localhost_header.json';
our $cpanel_proxy_file                 = '/etc/nginx/conf.d/includes-optional/cpanel-proxy-xt.conf';

my $nginxroot = "/etc/nginx";

my $cmds = {
    config => {
        code     => \&config,
        clue     => "config [--all|--global|<user>] [--no-reload]",
        abstract => 'Build nginx configuration for users',
        help     => "Build nginx configuration for one or all users.\n\t--global will only rebuild global configurations and executes anything in /etc/nginx/ea-nginx/config-scripts/global/\n\t--all implies --global and re-does configuration for all users",
    },
    reload => {
        code     => \&reload,
        clue     => "reload",
        abstract => 'reload nginx configuration',
        help     => "reload nginx configuration - a convenience for `restartsrv_nginx reload` (useful after multiple changes w/ --no-reload)",
    },
    remove => {
        code     => \&remove,
        clue     => "remove <user> [--no-reload]",
        abstract => "remove a given user’s nginx configuration",
        help     => "Remove the given user’s nginx configuration. Only does the generated conf.d/user/<user>.conf, does not touch the user customization directory conf.d/users/<user>/",
    },
    clear_cache => {
        code     => \&clear_cache_cmd,
        clue     => "clear_cache [--all|<user1> <user2> ...]",
        abstract => 'Clear the cache for a user, some users, or all users.',
        help     => 'Clears a cache or caches. Pass the users you want to clear or none for all users.',
    },
    cache => {
        code     => \&cache_config,
        clue     => "cache [--system|<user>] [--no-rebuild] [[--reset|--enabled=[1|0]]]",
        abstract => "Manage cache configuration at the system or user level",
        help     => "View, configure, reset NGINX caching at the system or user level\n\n\t--no-rebuild will make it skip the config regeneration and NGINX reload necessary to make the changes take effect\n\n\t--reset w/ --system will reset the system level config to the defaults\n\t--reset w/ a user will remove the user’s config effectively resetting it to the system level config\n",
    },
};

my $hint_blurb = "Usage: `$0 {command} …`.\n\tThis tool supports the following commands:";
my $opts       = {
    'help:pre_hint'  => $hint_blurb,
    'help:pre_help'  => "Various ea-nginx related admin utilities\n\n$hint_blurb",
    default_commands => "help",
    alias            => { conf => "config" },
    'help:post_help' => "More information on `ea-nginx` (what works and what does not, how to customize configuration, etc)\n  can be found at https://go.cpanel.net/ea-nginx.",
};

run(@ARGV) if !caller;

sub run {
    my (@argv) = @_;
    die "This script should only be called as root\n" if $> != 0;

    local $ENV{TERM} = $ENV{TERM} || "xterm-256color";    # non-CLI modulino avoid needless: Cannot find termcap: TERM not set at …/Term/ReadLine.pm line 373.
    require App::CmdDispatch;
    import App::CmdDispatch;

    # need to have App::CmdDispatch do this automatically see CPANEL-22328
    if ( @argv && grep { defined && m/\A\-\-help\z/ } @argv ) {
        App::CmdDispatch->new( $cmds, $opts )->help();
        exit(0);
    }

    my $orig_command_hint = \&App::CmdDispatch::command_hint;
    no warnings "redefine";
    local *App::CmdDispatch::command_hint = sub {
        $orig_command_hint->(@_);
        exit(1);
    };
    no warnings 'once';
    require App::CmdDispatch::IO;
    local *App::CmdDispatch::IO::print = sub {
        shift;
        if ( ref($@) && $@ =~ m/^App::CmdDispatch::Exception/ ) {
            CORE::print STDERR @_;
            return;
        }
        CORE::print(@_);
        return;
    };
    use warnings 'once';

    # ^^^ /need to have App::CmdDispatch do this automatically see CPANEL-22328

    my $custom_settings_path = path("/var/nginx/ea-nginx/settings.json");
    if ( $custom_settings_path->exists ) {

        # do not allow specifying apache_ ones
        my $new = Cpanel::JSON::LoadFile("/var/nginx/ea-nginx/settings.json");
        my $cur = Cpanel::JSON::LoadFile($settings_file);
        for my $key (qw(apache_port apache_port_ip apache_ssl_port apache_ssl_port_ip)) {
            $new->{$key} = $cur->{$key};
        }
        _write_json( "/var/nginx/ea-nginx/settings.json", $new );
        $custom_settings_path->move($settings_file);
    }

    my $custom_cache_path = path("/var/nginx/ea-nginx/cache.json");
    $custom_cache_path->move($cache_file) if $custom_cache_path->exists;

    return App::CmdDispatch->new( $cmds, $opts )->run(@argv);
}

################
#### commands ##
################

sub remove {
    my ( $app, $user, @args ) = @_;

    _validate_user_arg( $app, $user );

    my $file = "$nginxroot/conf.d/users/$user.conf";
    my $dir  = "$nginxroot/conf.d/users/$user/";

    if ( -f $file ) {
        print "Removing $file …\n";
        unlink $file;
        if ( -f $file ) {
            die "Unable to remove $file\n";
        }
        unless ( grep { $_ eq '--no-reload' } @args ) {
            _reload();
            clear_cache($user);
        }

    }
    else {
        print "$file is already removed or never existed.\n";
    }

    if ( -d $dir ) {
        warn "Customization path $dir exists, you will need to manually move/remove/reconfigure that.\n";
    }
    else {
        print "Customization path $dir does not exist. You are all set!\n";
    }

    return;
}

sub config {
    my ( $app, $user, @args ) = @_;

    my $reload = grep( { $_ eq '--no-reload' } @args ) ? 0 : 1;

    if ( $user eq '--all' || $user eq '--global' ) {
        _write_global_cpanel_localhost();
        _write_global_logging();
        _write_global_passenger();
        _write_global_ea_nginx();
        _write_global_nginx_conf();
        _write_global_default();
        _write_global_cpanel_proxy_non_ssl();
        _do_other_global_config();

        my %errors;
        if ( $user eq '--all' ) {
            mkdir "/etc/nginx/conf.d/users/";
            unlink( File::Glob::bsd_glob("/etc/nginx/conf.d/users/*.conf") );
            my $user_lookup = _get_user_domains();
            mce_loop {
                my ( $mce, $chunk_ref ) = @_;

                foreach my $usr (@$chunk_ref) {
                    eval { _write_user_conf($usr); };
                    MCE->gather( $usr, $@ ) if $@;
                }
            }
            keys %$user_lookup;
        }

        if ($reload) {
            _reload();
            clear_cache();
        }

        if ( keys %errors ) {
            my $err = "";
            for my $usr ( sort keys %errors ) {
                $err .= "\tUser “$usr”: $errors{$usr}\n\n";
            }

            die "The following user related errors need attention:\n$err";
        }
    }
    else {
        _validate_user_arg( $app, $user );
        mkdir "/etc/nginx/conf.d/users/";

        _populate_domain_ips_except($user);
        _write_user_conf($user);
        if ($reload) {
            _reload("/etc/nginx/conf.d/users/$user.conf");
            clear_cache($user);
        }
    }

    return 1;
}

sub cache_config {
    my ( $app, $which, @flags ) = @_;
    die "First argument to `cache` must be `--system` or a cPanel user name\n" if !length $which;

    my $file       = $cache_file;
    my $config_arg = "--all";

    if ( $which ne "--system" ) {
        _validate_user_arg( $app, $which );
        $file       = $var_cpanel_userdata . "/$which/nginx-cache.json";
        $config_arg = $which;
    }

    if ( !@flags ) {
        print eval { path($file)->slurp } || "{}\n";
    }
    else {
        require Getopt::Param::Tiny;
        my $prm = Getopt::Param::Tiny->new(
            {
                array_ref    => \@flags,
                known_only   => [qw(reset enabled no-rebuild)],
                help_coderef => sub { $app->help(); exit(1) },
                validate     => sub {
                    my ($prm) = @_;
                    my @given = grep { $_ ne "reset" && $_ ne "no-rebuild" } @{ $prm->param() };

                    die "--reset does not make sense w/ other flags (besides --no-rebuild)\n" if $prm->param('reset') && @given;

                    return 1;
                },
            }
        );

        if ( $prm->param('reset') ) {
            if ( $which eq "--system" ) {
                my %caching_defaults = caching_defaults();
                _jsonify_caching_booleans( \%caching_defaults );
                _write_json( $file, \%caching_defaults );
            }
            else {
                unlink $file;
            }
        }
        else {
            my $conf_hr = eval { Cpanel::JSON::LoadFile($file) } || {};

            # always set it since its the only option until ZC-8549
            $conf_hr->{enabled} = _bool_param( enabled => scalar( $prm->param('enabled') ) );

            # ZC-8549 example:
            # my %given_params;
            # @given_params{ $prm->param() } = ();
            # for my $bool (qw(enabled x_cache_header logging)) {
            #    next if !exists $given_params{$bool}; # only set it if given
            #    $conf_hr->{$bool} = _bool_param( $bool => scalar($prm->param($bool)) );
            # }
            #
            # if (exists $given_params{zone_size}) {
            #    my $zone_size = $prm->param('zone_size');
            #    die "Invalid --zone_size, it must …\n" if … $zone_size;
            #    $conf_hr->{zone_size} = $zone_size;
            # }

            _jsonify_caching_booleans($conf_hr);
            _write_json( $file, $conf_hr );
        }

        config( $app, $config_arg ) unless $prm->param("no-rebuild");
    }

    return 1;

}

sub clear_cache_cmd {
    my ( $app, @users ) = @_;

    if ( @users == 0 || $users[0] eq '--all' ) {
        shift @users;
        die "--all can not be mixed with usernames\n" if @users;
    }
    else {
        foreach my $user (@users) {
            _validate_user_arg( $app, $user );
        }
    }

    clear_cache(@users);

    return 1;
}

sub clear_cache {
    my (@users) = @_;

    if (@users) {
        foreach my $user (@users) {
            _delete_glob( $var_cache_ea_nginx . "/*/$user/*" );
        }
    }
    else {
        _delete_glob( $var_cache_ea_nginx . "/*/*/*" );
    }

    return 1;
}

sub reload { _reload(); clear_cache(); }

###############
#### helpers ##
###############

my $wants_http2;

sub _wants_http2 {
    if ( !defined $wants_http2 ) {
        $wants_http2 = -e "/etc/nginx/conf.d/http2.conf" ? 1 : 0;
    }

    return $wants_http2;
}

my $has_ipv6;

sub _has_ipv6 {
    $has_ipv6 //= -f '/proc/net/if_inet6' ? 1 : 0;
    return $has_ipv6;
}

sub ensure_valid_nginx_config {
    my ($depth) = @_;
    $depth //= 0;

    # limit recursion depth to 25
    my $max_depth = 25;

    my $nginx_bin = _get_nginx_bin();

    my $combined_output = '';
    my $output_handler  = IO::Callback->new( '>', sub { $combined_output .= shift } );
    my $run             = Cpanel::SafeRun::Object->new(
        program => $nginx_bin,
        args    => ['-t'],
        stdout  => $output_handler,
        stderr  => $output_handler,
    );

    my $resolved_issue;
    if ( $run->CHILD_ERROR() ) {
        $resolved_issue = _attempt_to_fix_syntax_errors($combined_output);
    }
    else {
        print "Verified valid syntax for nginx configuration\n";
        return;
    }

    ( $resolved_issue && $depth < $max_depth )
      ? return ensure_valid_nginx_config( ++$depth )
      : die "Unable to ensure a valid nginx configuration:\n\n$combined_output\n\nYou will need to manually resolve this issue.\n";

    return;
}

sub caching_defaults {    # do not want `our %caching_defaults` or a hash reference so that no one can accidentally change it

    # non-micro
    my %defaults = (
        proxy_cache_valid => {
            "200 301 302" => "60m",
            "404"         => "1m",
        },
    );

    if ( -e '/etc/nginx/ea-nginx/enable.micro-cache-defaults' ) {

        # micro
        %defaults = (
            proxy_cache_valid => {
                "301 302" => "5m",
                "404"     => "1m",
            },
        );
    }

    # hard coded fallback in case they remove stuff from /etc/nginx/ea-nginx/cache.json
    return (
        %defaults,
        enabled                       => 1,
        logging                       => 0,
        x_cache_header                => 0,
        zone_size                     => "10m",
        inactive_time                 => "60m",
        levels                        => "1:2",
        proxy_cache_use_stale         => "error timeout http_429 http_500 http_502 http_503 http_504",
        proxy_cache_background_update => "on",
        proxy_cache_revalidate        => "on",
        proxy_cache_min_uses          => 1,
        proxy_cache_lock              => "on",
    );
}

sub _bool_param {
    my ( $flag, $value ) = @_;

    die "--$flag value must be 1 or 0\n" if !defined $value || ( $value ne "1" && $value ne "0" );

    return $value;
}

sub _jsonify_caching_booleans {
    my ($hr) = @_;

    require JSON::PP;
    for my $boolkey (qw(enabled logging x_cache_header)) {
        next if !exists $hr->{$boolkey};
        $hr->{$boolkey} = $hr->{$boolkey} ? JSON::PP::true() : JSON::PP::false();
    }

    return;
}

sub _write_json {
    my ( $file, $ref ) = @_;

    my $transaction = Cpanel::Transaction::File::JSON->new( path => $file, "permissions" => 0644 );
    $transaction->set_data($ref);

    $transaction->save_pretty_canonical_or_die();
    $transaction->close_or_die();

    return 1;
}

my $tt;

sub _render_tt_to_file {
    my ( $tt_file, $output_file, $tt_data ) = @_;

    $tt ||= Template->new( { INCLUDE_PATH => "/etc/nginx/" } );

    my $output_path = "/etc/nginx/conf.d/$output_file";
    path($output_path)->touchpath;

    my $output_tt = path("/etc/nginx/ea-nginx/$tt_file")->slurp;

    $tt->process(
        \$output_tt, $tt_data,
        sub {
            my ($out) = @_;
            path($output_path)->spew($out);
            return 1;
        }
    );

    if ( $tt->error() ) {
        my $tt_err = $tt->error();
        unlink $output_path;
        die "$tt_err\nFailed to ensure “$output_path” does not exist: $!\n" if -e $output_path;
        die $tt_err;
    }

    return 1;
}

sub _do_other_global_config {

    # /etc/nginx/ea-nginx/config-scripts/global/* allows for future
    #  _do_other_config_user($user) via /etc/nginx/ea-nginx/config-scripts/user/*

    for my $script ( File::Glob::bsd_glob("/etc/nginx/ea-nginx/config-scripts/global/*") ) {

        # Seen during the install of ea-modsec30-connector-nginx
        # During the install of multiple packages, the script
        #     - May not actually be completely there it ends in .dpkg-new
        #     - May not be executable
        if ( -x $script && $script !~ m/dpkg-new$/ ) {
            print "Running (global) “$script” …\n";
            system($script) && warn "“$script” did not exit clean\n";
        }
        else {
            print "Skipping “$script” as it is not executable\n";
        }
    }

    return;
}

sub _get_application_paths {
    my ($app) = @_;

    # This sub does not exist in older versions of cPanel
    return Cpanel::Config::userdata::PassengerApps->ensure_paths( $app, 0 ) if defined &Cpanel::Config::userdata::PassengerApps::ensure_paths;

    # This is copied out of ulc as a fallback for older versions that do not have the above yet
    # TODO: remove the fallback once only 94 and newer are supported
    my $new                = 0;
    my %pre_multi_binaries = (
        ruby   => "/opt/cpanel/ea-ruby24/root/usr/libexec/passenger-ruby24",
        nodejs => "/opt/cpanel/ea-nodejs10/bin/node",
        python => "/usr/bin/python3",
    );

    for my $type ( keys %pre_multi_binaries ) {
        if ( !exists $app->{$type} ) {    # this and !$new means they have pre-94/pre_multi_binary-only …
            my $pre_multi_binary = $pre_multi_binaries{$type};
            if ( !$new && -x $pre_multi_binary ) {    # … so set them to that explicitly in case passeneger moves on to a newer version
                $app->{$type} = $pre_multi_binary;
            }
            elsif ( my $current_default = Cpanel::LoadFile::load_if_exists("/etc/cpanel/ea4/passenger.$type") ) {
                if ( !$new ) {
                    warn "The “$app->{name}” application‘s “$type” value ($pre_multi_binary) is not executable/does not exist.\n";
                    warn "The current default, $current_default, will be in effect for the “\$app->{name}” application.\n";
                }
                $app->{$type} = $current_default;
            }
        }
        else {
            if ( !defined $app->{$type} ) {
                warn "The “$app->{name}” application has “$type” but it is not defined, removing …\n";
                delete $app->{$type};
                next;
            }

            warn "The “$app->{name}” application’s “$type” value ($app->{$type}) is not executable/does not exist.\n" if !-x $app->{$type};
        }
    }

    return;
}

sub _write_global_cpanel_localhost {

    # regen new value if its not set or if its been at least half an hour
    _write_cpanel_localhost_header() if !-e $proxy_header_file || ( stat(_) )[9] < ( time() - 1800 );

    my $conf = Cpanel::JSON::LoadFile($proxy_header_file);
    my $val  = $conf->{'cPanel-localhost'} || _write_cpanel_localhost_header();

    my $path     = Path::Tiny::path($cpanel_proxy_file);
    my $contents = <<"CPANEL_PROXY";
proxy_set_header cPanel-localhost $val;

# for secure use of proxying to Apache w/ mod_remoteip
proxy_headers_hash_bucket_size 80;
proxy_set_header X-Forwarded-For-$val \$proxy_add_x_forwarded_for;
CPANEL_PROXY
    $path->spew($contents);
    $path->chmod(0600);

    return;
}

sub _write_cpanel_localhost_header {
    my $rand = Cpanel::Rand::Get::getranddata(64);

    # Though technically legal, NGINX does not like _ in header names (for good reason honestly)
    # and we want to do things like: proxy_set_header X-Forwarded-For-<RAND> …;
    $rand =~ s/_/-/g;

    my %headers = (
        'cPanel-localhost' => $rand,
    );

    _write_json( $proxy_header_file, \%headers );
    chmod 0600, $proxy_header_file;    # in case it is reset out form under the package
    _rebuild_and_restart_apache();     # needed so that apache can pick up the new header file
    return $headers{"cPanel-localhost"};
}

sub _write_global_nginx_conf {
    my $val            = "auto";
    my $local_settings = Cpanel::JSON::LoadFile($settings_file);
    if ( exists $local_settings->{worker_processes} && $local_settings->{worker_processes} ne "auto" ) {
        if ( $local_settings->{worker_processes} =~ m/^[1-9][0-9]*$/ ) {
            $val = $local_settings->{worker_processes};
        }
        else {
            warn "Custom `worker_processes` in “$settings_file” is not a number, falling back to “auto” …\n";
        }
    }

    my $main = path("/etc/nginx/nginx.conf");
    my $cont = $main->slurp;
    $cont =~ s/^(\s*worker_processes\s+)\S+(\s*;)/$1$val$2/gm;
    $main->spew($cont);

    return 1;
}

sub _write_global_cpanel_proxy_non_ssl {
    my $ipv6   = _has_ipv6();
    my $prefix = $ipv6 ? "" : "# server does not have IPv6 enabled: ";

    my $cpns    = path("/etc/nginx/conf.d/cpanel-proxy-non-ssl.conf");
    my $content = $cpns->slurp;

    # toggle IPv6
    $content =~ s/^.*(listen\s+\[::\]:)/    $prefix$1/gm;

    $cpns->spew($content);

    return 1;
}

sub _write_global_default {
    my $ipv6   = _has_ipv6();
    my $prefix = $ipv6 ? "" : "# server does not have IPv6 enabled: ";

    my $dflt    = path("/etc/nginx/conf.d/default.conf");
    my $content = $dflt->slurp;

    # toggle IPv6
    $content =~ s/^.*(listen\s+\[::\]:)/    $prefix$1/gm;

    # toggle the pem
    if ( -f "/var/cpanel/ssl/cpanel/mycpanel.pem" ) {

        # ensure it is /var/cpanel/ssl/cpanel/mycpanel.pem
        $content =~ s{/var/cpanel/ssl/cpanel/cpanel\.pem}{/var/cpanel/ssl/cpanel/mycpanel.pem}gm;
    }
    else {
        # ensure it is /var/cpanel/ssl/cpanel/cpanel.pem
        $content =~ s{/var/cpanel/ssl/cpanel/mycpanel\.pem}{/var/cpanel/ssl/cpanel/cpanel.pem}gm;
    }

    # ¿YAGNI? we could check and warn if there ia an ssl_certificate_key or ssl_certificate
    #   that is not /var/cpanel/ssl/cpanel/mycpanel.pem or /var/cpanel/ssl/cpanel/cpanel.pem

    if ( _wants_http2() ) {
        $content =~ s{443 ssl;}{443 ssl http2;}gm;
    }
    else {
        $content =~ s{443 ssl http2;}{443 ssl;}gm;
    }

    $dflt->spew($content);

    return 1;
}

sub _write_global_passenger {

    my $defaults_hr = { name => "global passenger defaults" };
    _get_application_paths($defaults_hr);

    my $passenger_root = $defaults_hr->{ruby};
    $passenger_root =~ s{/[^/]+$}{/../share/passenger/phusion_passenger/locations.ini};

    my $passenger_instance_registry_dir = $defaults_hr->{ruby};
    $passenger_instance_registry_dir =~ s{/[^/]+$}{/../../var/run/passenger-instreg};

    return _render_tt_to_file(
        'ngx_http_passenger_module.conf.tt' => 'passenger.conf',
        {
            passenger => {
                global => {
                    passenger_root                  => $passenger_root,
                    passenger_instance_registry_dir => $passenger_instance_registry_dir,
                    default                         => $defaults_hr,
                },
            },
        },
    );

}

my $settings_hr;

sub _get_settings_hr {
    if ( !defined $settings_hr ) {
        my $global_settings = Cpanel::JSON::LoadFile($settings_file);
        $settings_hr = {
            _settings_defaults(),
            %{$global_settings},
        };
    }

    return $settings_hr;
}

sub _write_global_ea_nginx {
    my $cur_settings = _get_settings_hr();
    my $ea4_conf_hr  = eval { require Cpanel::EA4::Conf; 1 } ? Cpanel::EA4::Conf->instance->as_hr() : {};

    my $vhosts = _get_httpd_vhosts_hash();
    my %ips    = map { $vhosts->{$_}{ip} => 1 } keys %{$vhosts};

    return _render_tt_to_file(
        'ea-nginx.conf.tt' => 'ea-nginx.conf',
        { ea4conf => $ea4_conf_hr, settings => $cur_settings, ips => [ sort keys %ips ] }
    );
}
our $cpconf_hr;

sub _settings_defaults {

    $cpconf_hr ||= _get_cpconf_hr();

    my %ports;
    foreach my $key ( 'apache_port', 'apache_ssl_port' ) {
        $ports{$key} = $cpconf_hr->{$key} =~ /:([0-9]+)$/ ? $1 : 0;
        if ( $ports{$key} < 1 || $ports{$key} > 65535 ) {    # last ditch fall back if cpconf has an invalid value
            $ports{$key} = $key eq 'apache_port' ? 81 : 444;
        }
    }

    # hard coded fallback in case they remove stuff from /etc/nginx/ea-nginx/settings.json
    return (
        apache_port                   => $ports{apache_port},
        apache_port_ip                => '127.0.0.1',
        apache_ssl_port               => $ports{apache_ssl_port},
        apache_ssl_port_ip            => '127.0.0.1',
        server_names_hash_bucket_size => 128,
        server_names_hash_max_size    => 1024,
        client_max_body_size          => '128m',
    );
}

sub _write_global_logging {

    my $logging_hr = _get_logging_hr();
    _render_tt_to_file(
        'global-logging.tt' => 'global-logging.conf',
        {
            logging  => $logging_hr,
            hostname => scalar( Cpanel::Hostname::gethostname() ),
        },
    );

    my $piped_module_conf = "/etc/nginx/conf.d/modules/ngx_http_pipelog_module.conf";
    if ( $logging_hr->{piped_logs} ) {
        path($piped_module_conf)->spew("load_module modules/ngx_http_pipelog_module.so;");
    }
    else {
        unlink $piped_module_conf;
        die "Failed to ensure “$piped_module_conf” does not exist: $!\n" if -e $piped_module_conf;
    }

    return 1;
}

sub _reload {
    my ($new_file) = @_;

    ensure_valid_nginx_config();    # dies if it fails to ensure a valid config

    if ( system("/usr/local/cpanel/scripts/restartsrv_nginx reload") != 0 ) {
        if ($new_file) {
            warn "Could not reload generated nginx config, removing and attempting reload without it: $?\n";
            unlink $new_file;
            system("/usr/local/cpanel/scripts/restartsrv_nginx reload") || return 1;
        }
        exit 1;
    }

    return 1;
}

sub _write_user_conf {
    my ($user) = @_;

    my $domains_data = Cpanel::Config::userdata::Load::load_userdata_main($user);
    my %addon_subdomains;
    @addon_subdomains{ values %{ $domains_data->{addon_domains} } } = ();
    my @actual_subdomains = grep { !exists $addon_subdomains{$_} } @{ $domains_data->{sub_domains} };

    my $mail_subdomain_exists = scalar grep { $_ eq 'mail.' . $domains_data->{main_domain} } @actual_subdomains;

    my $userconf = "/etc/nginx/conf.d/users/$user.conf";

    print "Setting up $userconf …\n";

    if ( !defined &scripts::ea_nginx_userdata::run ) {
        my $prefix = "/usr/local/cpanel/scripts/ea-nginx";
        if ( $0 =~ m{/SOURCES/} ) {

            # Can’t use FindBin because the script name is different in repo and in RPM
            require Cwd;
            $prefix = Cwd::abs_path($0);
        }

        require "$prefix-userdata";
    }
    scripts::ea_nginx_userdata::run($user);

    my $caching_hr = _get_caching_hr($user);
    my $pre_server = "";
    if ( $caching_hr->{enabled} ) {
        $pre_server = "proxy_cache_path /var/cache/ea-nginx/proxy/$user levels=$caching_hr->{levels} keys_zone=$user:$caching_hr->{zone_size} inactive=$caching_hr->{inactive_time};\n\n";
    }

    path($userconf)->spew( $pre_server . "#### main domain for $user ##\n" );
    _render_and_append( $user => [ $domains_data->{main_domain}, @{ $domains_data->{parked_domains} } ], $mail_subdomain_exists );

    if (@actual_subdomains) {
        path($userconf)->append("\n#### sub domains for $user ##\n");
        for my $subdom (@actual_subdomains) {
            _render_and_append( $user => [$subdom] );
        }
    }

    if ( keys %{ $domains_data->{addon_domains} } ) {
        path($userconf)->append("\n#### addon domains for $user ##\n");
        for my $aod ( sort keys %{ $domains_data->{addon_domains} } ) {
            my $sub = $domains_data->{addon_domains}{$aod};
            _render_and_append( $user => [ $sub, $aod ] );
        }
    }

    return 1;
}

our ( $server_tt, $docroots, $logging_hr, $caching_cache, $global_caching );

sub caching_global {
    my $caching_global = Cpanel::JSON::LoadFile($cache_file);

    # UGMO :/ clean it up if the touch file exists and they have the defaults
    # if they happen to edit it and make it the default and they really want that then they should not have this touchfile
    if ( -e '/etc/nginx/ea-nginx/enable.micro-cache-defaults' ) {

        # only change it if its the non-micro default
        if (   keys %{ $caching_global->{proxy_cache_valid} } == 2
            && exists $caching_global->{proxy_cache_valid}{"200 301 302"}
            && $caching_global->{proxy_cache_valid}{"200 301 302"} eq "60m"
            && exists $caching_global->{proxy_cache_valid}{404}
            && $caching_global->{proxy_cache_valid}{404} eq "1m" ) {

            warn "Changing default `proxy_cache_valid` to micro-cache version per the existance of the `/etc/nginx/ea-nginx/enable.micro-cache-defaults` touch-file\n";
            delete $caching_global->{proxy_cache_valid}{"200 301 302"};
            $caching_global->{proxy_cache_valid}{"301 302"} = "5m";
            _write_json( $cache_file, $caching_global );
        }
    }
    else {
        # only change it back if its the micro default
        if (   keys %{ $caching_global->{proxy_cache_valid} } == 2
            && exists $caching_global->{proxy_cache_valid}{"301 302"}
            && $caching_global->{proxy_cache_valid}{"301 302"} eq "5m"
            && exists $caching_global->{proxy_cache_valid}{404}
            && $caching_global->{proxy_cache_valid}{404} eq "1m" ) {

            warn "Changing default `proxy_cache_valid` to non-micro-cache version per the absence of the `/etc/nginx/ea-nginx/enable.micro-cache-defaults` touch-file\n";
            $caching_global->{proxy_cache_valid}{"200 301 302"} = "60m";
            delete $caching_global->{proxy_cache_valid}{"301 302"};
            _write_json( $cache_file, $caching_global );
        }
    }

    return $caching_global;
}

sub _get_caching_hr {
    my ($user) = @_;

    if ( !exists $caching_cache->{$user} ) {

        # at this point that file should exist; if it does not we want this to barf so we know about it
        $global_caching //= caching_global();

        my $user_caching = eval { Cpanel::JSON::LoadFile("/var/cpanel/userdata/$user/nginx-cache.json") } || {};
        $caching_cache->{$user} = {
            caching_defaults(),
            %{$global_caching},
            %{$user_caching},
        };
    }

    return $caching_cache->{$user};
}

sub _get_logging_hr {
    return $logging_hr if $logging_hr;

    $logging_hr->{piped_logs}          = Whostmgr::TweakSettings::get_value( Main => 'enable_piped_logs' );
    $logging_hr->{default_format_name} = Cpanel::Config::LoadWwwAcctConf::loadwwwacctconf()->{LOGSTYLE} || "combined";
    $logging_hr->{loglevel}            = "warn";

    $global_caching //= caching_global();
    $logging_hr->{enable_cache_log} = $global_caching->{logging};

    if ( $logging_hr->{default_format_name} ne "combined" && $logging_hr->{default_format_name} ne "common" ) {
        warn "Invalid “LOGSTYLE”, using `combined`\n";
        $logging_hr->{default_format_name} = "combined";
    }

    if ( eval { require Cpanel::EA4::Conf::Tiny; 1 } ) {
        my $e4c = Cpanel::EA4::Conf::Tiny::get_ea4_conf_hr();

        $logging_hr->{loglevel} = $e4c->{loglevel};
    }

    return $logging_hr;
}

my %group_cache;

sub _get_group_for {
    my ($user) = @_;
    return $group_cache{$user} if $group_cache{$user};

    # prefer: group same name as user
    $group_cache{$user} = scalar getgrnam($user) ? $user : undef;
    return $group_cache{$user} if $group_cache{$user};

    # otherwise: via gid
    my $gid = ( getpwnam($user) )[3];
    $group_cache{$user} = getgrgid($gid);

    return $group_cache{$user};
}

our $domains_with_ssl;

sub _get_domains_with_ssls {
    my %ssl_vhosts = map {
        $_ =~ s/_SSL$//;
        $_ => 1
    } grep { substr( $_, -4 ) eq '_SSL' ? 1 : 0 } keys %{ _get_httpd_vhosts_hash() };

    return \%ssl_vhosts;
}

our $httpd_vhosts_hr;

sub _get_httpd_vhosts_hash {
    return unless ( eval { require Cpanel::ConfigFiles::Apache::Config; 1; } );

    $httpd_vhosts_hr ||= Cpanel::ConfigFiles::Apache::Config::get_httpd_vhosts_hash();

    return $httpd_vhosts_hr;
}

my $standalone;

my %domain_ips;

sub _populate_domain_ips_except {
    my ($user) = @_;

    my %seen_ips;
    my $user_lookup = _get_user_domains();
    for my $usr ( sort keys %$user_lookup ) {
        my $domain = Cpanel::Config::userdata::Load::load_userdata_main($usr)->{main_domain};
        my $ip     = Cpanel::DomainIp::getdomainip($domain);
        if ( $ip && !exists $seen_ips{$ip} ) {
            $seen_ips{$ip}++;
            $domain_ips{$ip}++ if $user ne $usr;
        }
    }

    return;
}

sub _render_and_append {
    my ( $user, $domains, $mail_subdomain_exists ) = @_;

    my $group = _get_group_for($user);

    # at this point that file should exist; if it does not we want this to barf so we know about it
    my $cpanel_password_protected_directories = Cpanel::JSON::LoadFile("/var/cpanel/userdata/$user/cpanel_password_protected_directories.json");
    my $cpanel_redirects                      = Cpanel::JSON::LoadFile("/var/cpanel/userdata/$user/cpanel_redirects.json");

    my $userconf = "/etc/nginx/conf.d/users/$user.conf";
    $standalone //= -e "/etc/nginx/ea-nginx/enable.standalone" ? 1 : 0;
    $tt                ||= Template->new( { INCLUDE_PATH => "/etc/nginx/" } );
    $server_tt         ||= path("/etc/nginx/ea-nginx/server.conf.tt")->slurp;
    $docroots->{$user} ||= { Cpanel::DomainLookup::DocRoot::getdocroots($user) };
    my $docroot = $docroots->{$user}{ $domains->[0] };

    my $basic_auth       = _get_basic_auth( $user, $docroot, $cpanel_password_protected_directories );
    my $redirects        = _get_redirects( $domains, $cpanel_redirects );
    my $logging_hr       = _get_logging_hr();
    my $ssl_redirect     = _get_ssl_redirect( $user => $domains );
    my $secruleengineoff = -e "/etc/nginx/conf.d/modules/ngx_http_modsecurity_module.conf" ? _get_secruleengineoff( $user => $domains ) : 0;
    my $passenger_apps   = _get_passenger_apps( $user => $domains );
    my $caching_hr       = _get_caching_hr($user);

    my $ipv6  = _has_ipv6();
    my $http2 = _wants_http2();
    my $gid   = ( Cpanel::PwCache::getpwnam($user) )[3];

    # create no matter what because the are either used directly or via piped logging
    Cpanel::FileUtils::TouchFile::touchfile("/var/log/nginx/domains/$domains->[0]");
    chmod 0640, "/var/log/nginx/domains/$domains->[0]";
    chown 0, $gid, "/var/log/nginx/domains/$domains->[0]";

    Cpanel::FileUtils::TouchFile::touchfile("/var/log/nginx/domains/$domains->[0]-bytes_log");
    chmod 0644, "/var/log/nginx/domains/$domains->[0]-bytes_log";
    chown 0, 0, "/var/log/nginx/domains/$domains->[0]-bytes_log";

    if ( -f "/var/log/nginx/domains/$domains->[0]-ssl_log" ) {
        chown 0, $gid, "/var/log/nginx/domains/$domains->[0]-ssl_log";
    }

    # Include numeric UID if they want it
    my $uid;
    if ( -e "/etc/cpanel/ea4/option-flags/set-USER_ID" ) {
        $uid = ( Cpanel::PwCache::getpwnam($user) )[2];
    }

    my $fpm_socket;
    my $fpm_socket_php_major_version;
    for my $i ( 0, 1 ) {
        my $has_fpm = Cpanel::PHPFPM::Get::get_php_fpm( $user, $domains->[$i] );
        if ($has_fpm) {
            my $php_config_ref = Cpanel::PHP::Config::get_php_config_for_domains( [ $domains->[$i] ] )->{ $domains->[$i] };

            if ($php_config_ref) {
                my ( $proxy, $socket ) = Cpanel::PHPFPM::Get::get_proxy_from_php_config_for_domain($php_config_ref);
                $fpm_socket = $socket;
                if ( $fpm_socket =~ m{/\w+-php(\d)\d/} ) {
                    $fpm_socket_php_major_version = $1;
                }
            }
            elsif ($standalone) {
                warn "Could not find PHP configuration for “$domains->[$i]”, it will not be configured to use PHP-FPM\n";
            }

            last;
        }
    }

    $domains_with_ssl ||= _get_domains_with_ssls();

    my @service_subdomains;
    $httpd_vhosts_hr ||= _get_httpd_vhosts_hash();
    if ( exists $httpd_vhosts_hr->{"$domains->[0]_SSL"}{proxy_subdomains} ) {
        for my $sub ( sort keys %{ $httpd_vhosts_hr->{"$domains->[0]_SSL"}{proxy_subdomains} } ) {
            push @service_subdomains, map { "$sub.$_" } @{ $httpd_vhosts_hr->{"$domains->[0]_SSL"}{proxy_subdomains}{$sub} };
        }
    }

    my $combined_tls = Cpanel::Apache::TLS->get_tls_path( $domains->[0] );
    if ( !-f $combined_tls ) {
        if ( -f "/var/cpanel/ssl/cpanel/mycpanel.pem" ) {
            $combined_tls = "/var/cpanel/ssl/cpanel/mycpanel.pem";
        }
        else {
            $combined_tls = "/var/cpanel/ssl/cpanel/cpanel.pem";
        }
    }

    my $ip           = Cpanel::DomainIp::getdomainip( $domains->[0] ) || '127.0.0.1';    # juuust in case so we don’t break nginx w/ syntax error
    my $severname_ip = $ip ne '127.0.0.1' && $domain_ips{$ip}++ ? "" : $ip;              # avoid `conflicting server name "$ip"` warnings, sans worst case 127 fallback

    # Use the public IP on NAT systems
    # NOTE: this is fine to run on non-NAT systems as it just returns the same IP
    $severname_ip = Cpanel::NAT::get_public_ip($severname_ip) if $severname_ip;

    my $wordpress_hr  = _get_wordpress_info( $user, $docroots->{$user}{ $domains->[0] } );
    my $has_wordpress = ( $wordpress_hr->{docroot_install} || scalar @{ $wordpress_hr->{non_docroot_uris} } ) ? 1 : 0;

    $cpconf_hr ||= _get_cpconf_hr();

    my $cur_settings = _get_settings_hr();
    my $ea4_conf_hr  = eval { require Cpanel::EA4::Conf; 1 } ? Cpanel::EA4::Conf->instance->as_hr() : {};
    $tt->process(
        \$server_tt,
        {
            docroot             => $docroot,
            ssl_certificate     => $combined_tls,
            ssl_certificate_key => $combined_tls,
            ssl_redirect        => $ssl_redirect,
            secruleengineoff    => $secruleengineoff,
            domains             => $domains,
            service_subdomains  => \@service_subdomains,
            user                => $user,
            group               => $group,
            ( defined $uid ? ( uid => $uid ) : () ),
            proxy_ip                     => $ip,
            ip                           => $severname_ip,
            ipv6                         => $ipv6,
            http2                        => $http2,
            fpm_socket                   => $fpm_socket,
            fpm_socket_php_major_version => $fpm_socket_php_major_version,
            has_wordpress                => $has_wordpress,
            wordpress                    => {
                docroot_install  => $wordpress_hr->{docroot_install},
                non_docroot_uris => $wordpress_hr->{non_docroot_uris},
            },
            basic_auth => $basic_auth,
            redirects  => $redirects,
            logging    => $logging_hr,
            ea4conf    => $ea4_conf_hr,
            settings   => $cur_settings,
            passenger  => {
                apps => $passenger_apps,
            },
            behavior => {
                standalone => $standalone,
                caching    => $caching_hr,
            },
            proxysubdomains_enabled => $cpconf_hr->{proxysubdomains},
            mail_subdomain_exists   => $mail_subdomain_exists,
        },
        sub {
            my ($out) = @_;
            path($userconf)->append($out);
            return 1;
        }
    );

    if ( $tt->error() ) {
        unlink $userconf;
        die $tt->error();
    }

    return 1;
}

sub _get_homedir {
    my ($user) = @_;
    return ( getpwnam($user) )[7];
}

sub _get_passenger_apps {
    my ( $user, $domains ) = @_;
    my @apps;

    my %domains;
    @domains{ @{$domains} } = ();

    my $apps_hr = eval { Cpanel::JSON::LoadFile("/var/cpanel/userdata/$user/applications.json") } || {};

    for my $app_name ( sort keys %{$apps_hr} ) {
        my $app = $apps_hr->{$app_name};
        if ( $app->{enabled} && exists $domains{ $app->{domain} } ) {
            _get_application_paths($app);
            push @apps, $app;
        }
    }

    return \@apps;
}

our %load_userdata_cache;

sub _get_userdata_for {
    my ( $user, $dom ) = @_;

    if ( !exists $load_userdata_cache{$user}{$dom} ) {
        $load_userdata_cache{$user}{$dom} = Cpanel::Config::userdata::Load::load_userdata( $user => $dom ) || {};
    }

    return $load_userdata_cache{$user}{$dom};
}

sub _get_ssl_redirect {
    my ( $user, $domains ) = @_;

    for my $dom ( @{$domains} ) {
        my $lu = _get_userdata_for( $user => $dom );
        return 1 if $lu->{ssl_redirect};
    }

    return;
}

sub _get_secruleengineoff {
    my ( $user, $domains ) = @_;

    for my $dom ( @{$domains} ) {
        my $lu = _get_userdata_for( $user => $dom );
        return 1 if $lu->{secruleengineoff};
    }

    return;
}

sub _get_redirects {
    my ( $domains, $cpanel_redirects ) = @_;

    my %domains;
    @domains{ @{$domains} } = ();

    my @applicable_redirects;
    for my $redirect ( @{$cpanel_redirects} ) {
        next unless exists $domains{ $redirect->{domain} } || $redirect->{domain} eq '.*';

        if ( $redirect->{domain} ne '.*' ) {
            if ( $redirect->{targeturl} =~ m{^(?:[A-Za-z0-9\+_\.\-\:]+)?//(?:www\.)?\Q$redirect->{domain}\E(?:$|/|\?|\#)} ) {
                warn "Skipping circular redirect for “$redirect->{domain}” to “$redirect->{targeturl}”\n";
                next;
            }
        }

        my %res;
        if ( $redirect->{statuscode} eq "301" ) {
            $res{flag} = "permanent";
        }
        elsif ( $redirect->{statuscode} eq "302" ) {
            $res{flag} = "redirect";
        }
        else {
            warn "Skipping non 301/302 redirect\n";
            next;
        }

        # sourceurl and targeturl can be anything meaning a user would take down the server (not just their site) if its invalid
        # or worse they could inject configuration into nginx. We need to ensure nginx sees them as a single string.
        # Cpanel::UTF8::Utils::quotemeta() make sense for sourceurl since its a regex
        # 78 does not have Cpanel::UTF8::Utils so we use String::UnicodeUTF8 which it does have.
        # Escaping is bad for targeturl because the slashes are literal despite it being syntactically correct ¯\_(ツ)_/¯
        if ( !Cpanel::Validate::URL::is_valid_url( $redirect->{targeturl} ) ) {
            warn "Skipping invalid targeturl “$redirect->{targeturl}”\n";
            next;
        }

        if ( $redirect->{wildcard} ) {
            $res{regex} = $redirect->{sourceurl};
            $res{regex} =~ s{/+$}{};
            $res{regex}       = '^' . String::UnicodeUTF8::quotemeta_bytes( $res{regex} ) . '\\/?(.*)$';
            $res{replacement} = $redirect->{targeturl} . '$1';
        }
        else {
            $res{regex}       = '^' . String::UnicodeUTF8::quotemeta_bytes( $redirect->{sourceurl} ) . '$';
            $res{replacement} = $redirect->{targeturl};
        }

        push @applicable_redirects, \%res;
    }

    return \@applicable_redirects;
}

sub _get_basic_auth {
    my ( $user, $docroot, $cpanel_password_protected_directories ) = @_;

    my $docroot_rel = $docroot;
    my $homedir     = _get_homedir($user);
    $docroot_rel =~ s{\Q$homedir\E}{};
    my $basic_auth = $cpanel_password_protected_directories->{$docroot_rel};

    my $auth_file_from;
    if ( !$basic_auth ) {
        my $docroot_rel_copy = $docroot_rel;
        while ($docroot_rel_copy) {
            $docroot_rel_copy =~ s{/[^/]+$}{};
            if ( exists $cpanel_password_protected_directories->{$docroot_rel_copy} ) {
                $basic_auth     = $cpanel_password_protected_directories->{$docroot_rel_copy};
                $auth_file_from = $docroot_rel_copy;
                last;
            }
        }
    }

    $basic_auth ||= $cpanel_password_protected_directories->{""} || undef;
    if ($basic_auth) {
        $basic_auth->{auth_file} =
            $auth_file_from ? "$homedir/.htpasswds$auth_file_from/passwd"
          : $docroot_rel    ? "$homedir/.htpasswds$docroot_rel/passwd"
          :                   "$homedir/.htpasswds/passwd";
    }

    $basic_auth->{locations} = {};
    for my $dir ( keys %{$cpanel_password_protected_directories} ) {
        my $abs = "$homedir$dir";
        if ( $abs =~ m{^\Q$docroot\E(/.+)$} ) {
            my $loc = $1;
            $basic_auth->{locations}{$loc} = {
                auth_file  => "$homedir/.htpasswds$docroot_rel$loc/passwd",
                realm_name => $cpanel_password_protected_directories->{$dir}{realm_name},
            };
        }
    }

    return $basic_auth;
}

my $wordpress_lu;

sub _get_wp_uapi {
    my ($user) = @_;

    my $uapi = Cpanel::SafeRun::Object->new(
        program => "/usr/bin/uapi",
        args    => [ "--output=json", "--user=$user", "WordPressInstanceManager", "get_instances" ],
    );

    warn "Could not determine managed wordpress instances for $user\n" if $uapi->CHILD_ERROR();

    return eval { Cpanel::JSON::Load( $uapi->stdout() ) } || {};
}

my $wp_toolkit_list;

sub _get_wp_toolkit_list {
    my $run = Cpanel::SafeRun::Object->new(
        program => $wp_toolkit_bin,
        args    => [ '--list', '-format', 'json' ],
    );

    warn 'Could not determine managed wordpress instances via wordpress toolkit' if $run->CHILD_ERROR();

    return eval { Cpanel::JSON::Load( $run->stdout() ) } || [];
}

sub _get_wp_toolkit_list_for_user {
    my ( $user, $docroot, $res ) = @_;

    $wp_toolkit_list ||= _get_wp_toolkit_list();

    my ( @list, %non_docroot_uris );
    foreach my $wordpress_instance (@$wp_toolkit_list) {
        if ( $wordpress_instance->{fullPath} =~ m{/\Q$user\E/} ) {
            if ( $wordpress_instance->{fullPath} eq $docroot ) {
                $res->{docroot_install} = 1;
                next;
            }

            my $uri_from_path = $wordpress_instance->{fullPath};
            $uri_from_path =~ s{^\Q$docroot\E/}{};

            my $uri_from_siteurl = $wordpress_instance->{siteUrl};
            $uri_from_siteurl =~ s{^https?://[^/]+/}{};

            if ( $uri_from_path eq $uri_from_siteurl ) {
                $non_docroot_uris{$uri_from_path} = 1;
                next;
            }
        }

        push @list, $wordpress_instance;
    }

    # Do it this way in case there are duplicate entries in $wp_toolkit_list
    @{ $res->{non_docroot_uris} } = keys %non_docroot_uris;

    # Remove the entries in $res from the list since they will only match 1 time
    $wp_toolkit_list = \@list;

    return $res;
}

sub _get_wordpress_info {
    my ( $user, $docroot ) = @_;

    my $res;

    my $docroot_underscore = $docroot;
    $docroot_underscore =~ s{/}{_}g;
    my $cache_file = "$wordpress_cache_dir/${user}_${docroot_underscore}_wordpress_info.json";

    # Returns undef if the cache_file fails to load or does not contain the required keys
    $res = _get_wordpress_info_from_cache($cache_file) if _is_wordpress_info_cache_valid($cache_file);
    return $res                                        if defined $res;

    $res = {
        docroot_install  => 0,
        non_docroot_uris => [],
    };

    if ( -e $wp_toolkit_bin ) {
        $res = _get_wp_toolkit_list_for_user( $user, $docroot, $res );
    }
    elsif ( -e '/usr/local/cpanel/Cpanel/API/WordPressInstanceManager.pm' ) {
        $wordpress_lu->{$user} ||= _get_wp_uapi($user);
        $res = _get_wordpress_info_from_wpmanager( $docroot, $wordpress_lu->{$user}{result}{data}{instances}, $res );
    }

    # cache wordpress info
    _ensure_wordpress_info_cache_directory();
    _write_json( $cache_file, $res );

    return $res;
}

sub _get_wordpress_info_from_wpmanager {
    my ( $docroot, $wordpress_instances, $res ) = @_;

    # paths passed in and from API call do not have trailing slash, if that changes we could normalize them
    for my $wp_instance (@$wordpress_instances) {
        if ( length $wp_instance->{rel_path} ) {
            my $instance_docroot = $wp_instance->{full_path};
            $instance_docroot =~ s{/\Q$wp_instance->{rel_path}\E$}{};
            if ( $instance_docroot eq $docroot ) {
                push @{ $res->{non_docroot_uris} }, $wp_instance->{rel_path};
            }
        }
        else {
            if ( $wp_instance->{full_path} eq $docroot ) {
                $res->{docroot_install} = 1;
            }
        }
    }

    return $res;
}

sub _ensure_wordpress_info_cache_directory {
    mkdir $wordpress_cache_dir;
    return;
}

sub _is_wordpress_info_cache_valid {
    my ($cache_file) = @_;

    return 0 if -e $disable_wordpress_info_cache_file;

    my $now   = time();
    my $ttl   = 18000;                      # Cache it for 5 days
    my $mtime = ( stat($cache_file) )[9];

    return ( -s $cache_file && $mtime > ( $now - $ttl ) ) ? 1 : 0;
}

sub _get_wordpress_info_from_cache {
    my ($cache_file) = @_;

    my $res;
    unless ( eval { $res = Cpanel::JSON::LoadFile($cache_file); 1; } ) {
        warn "Failed to load cache file:  ‘$cache_file’\n";
        return;
    }

    if ( !exists $res->{docroot_install} || !exists $res->{non_docroot_uris} ) {
        warn "The cache file ‘$cache_file’ has missing data\n";
        return;
    }

    return $res;
}

sub _validate_user_arg {
    my ( $app, $user ) = @_;

    _bail( $app, "The user argument is missing." ) if !$user;

    my $user_lookup = _get_user_domains();
    _bail( $app, "The given user is not a cPanel user.\n" ) if !$user_lookup->{$user};

    return 1;
}

sub _get_cmd {
    return $cmds;
}

sub _bail {
    my ( $app, $msg ) = @_;
    chomp($msg);

    die "$msg\n" if $ENV{ __PACKAGE__ . "::bail_die" };    # for API calls, otherwise:

    warn "$msg\n";
    $app->help();
    exit(1);                                               # there is no return()ing from this lol
}

sub _delete_glob {
    my ($glob) = @_;

    for my $item ( File::Glob::csh_glob($glob) ) {

        # File::Path::Tiny::rm does not delete files
        if ( -l $item || -f _ ) {
            unlink($item);
        }
        elsif ( -d $item ) {
            File::Path::Tiny::rm($item);
        }
    }

    return;
}

sub _get_cpconf_hr {
    return Cpanel::Config::LoadCpConf::loadcpconf();
}

sub _get_nginx_bin {
    my $nginx_bin = '/usr/sbin/nginx';

    # This executable is provided by the ea-nginx RPM so this should never happen
    die "Could not find an executable nginx binary\n" unless -x $nginx_bin;
    return $nginx_bin;
}

sub _attempt_to_fix_syntax_errors {
    my ($combined_output) = @_;
    die "_attempt_to_fix_syntax_errors: ‘combined_output’ arg is required\n"
      unless defined $combined_output;

    my $resolved_issue = 0;
    my @output_lines   = split /\n/, $combined_output;
    foreach my $output_line (@output_lines) {

        # For example:
        # nginx: [emerg] "client_max_body_size" directive is duplicate in /etc/nginx/conf.d/ea-nginx.conf:19
        # use non greedy modifier here to ensure we do not match more than we intend to
        if ( $output_line =~ m{^nginx: \[emerg\] "(.*?)" directive is duplicate in (.*?):([0-9]+)$} ) {
            my $key       = $1;
            my $file_path = $2;
            my $line_num  = $3;

            die "‘$file_path’ reported an error on line $line_num.  However, ‘$file_path’ does not exist on the system\n"
              unless -s $file_path;

            my $file       = Path::Tiny::path($file_path);
            my @file_lines = $file->lines();
            chomp(@file_lines);
            $line_num--;    # avoid off by 1 error (line 42 in the file is item 41 in the array)

            # For example:
            # nginx_key value_for_key;
            if ( $file_lines[$line_num] =~ m{^\s*\Q$key\E.*;$} ) {
                $resolved_issue = 1;
                $file_lines[$line_num] = '# ' . $file_lines[$line_num];
                $line_num++;
                print "Line $line_num in the file ‘$file_path’ was commented out since another entry exists for the key:  $key\n";
            }

            $file->spew( join( "\n", @file_lines ) );
            last;    # nginx -t only reveals the first issue it encounters
        }

        # For example:
        # nginx: [emerg] could not build server_names_hash, you should increase server_names_hash_max_size: 2
        elsif ( $output_line =~ m{^nginx: \[emerg\] could not build server_names_hash, you should increase server_names_hash_max_size: ([0-9]+)$} ) {
            my $current_value     = $1;
            my $num_current_users = _get_num_current_users();
            last unless defined $num_current_users;

            # http://nginx.org/en/docs/http/server_names.html
            # The recommendation here is to set 'server_names_hash_max_size' to the number of server_names on the server
            # We are taking a more conservative approach here is that number is actually 7x the number
            # of users on the server at a minimum
            my $update_value = ( $num_current_users > $current_value ) ? $num_current_users : $current_value * 2;

            _update_global_ea_nginx_settings( 'server_names_hash_max_size', $update_value );
            _write_global_ea_nginx();
            $resolved_issue = 1;

            last;    # nginx -t only reveals the first issue it encounters
        }

        # For example:
        # nginx: [emerg] could not build server_names_hash, you should increase server_names_hash_bucket_size: 64
        elsif ( $output_line =~ m{^nginx: \[emerg\] could not build server_names_hash, you should increase server_names_hash_bucket_size: ([0-9]+)$} ) {
            my $current_value = $1;

            # http://nginx.org/en/docs/http/server_names.html
            # The recommendation here is to set 'server_names_hash_bucket_size' to the next power of 2
            # I am going to make the assumption that the initial value is a power of 2
            my $update_value = $current_value * 2;

            _update_global_ea_nginx_settings( 'server_names_hash_bucket_size', $update_value );
            _write_global_ea_nginx();
            $resolved_issue = 1;

            last;    # nginx -t only reveals the first issue it encounters
        }
    }

    return $resolved_issue;
}

sub _update_global_ea_nginx_settings {
    my ( $key, $value ) = @_;
    die "_update_global_ea_nginx_settings: ‘key’ arg is required\n"   unless $key;
    die "_update_global_ea_nginx_settings: ‘value’ arg is required\n" unless $value;

    my $user_settings_hr = Cpanel::JSON::LoadFile($settings_file);
    $user_settings_hr->{$key} = $value;
    _write_json( $settings_file, $user_settings_hr );

    print "Updated ‘$key’ to ‘$value’ since the current value is too low\n";
    return;
}

sub _get_num_current_users {
    return unless ( eval { require Cpanel::Config::LoadUserDomains::Count; 1; } );
    return Cpanel::Config::LoadUserDomains::Count::counttrueuserdomains();
}

my $user_domains;

sub _get_user_domains {
    $user_domains //= Cpanel::Config::LoadUserDomains::loaduserdomains( undef, 0, 1 );
    return $user_domains;
}

sub _rebuild_and_restart_apache {
    my $run = Cpanel::SafeRun::Object->new(
        program => '/usr/local/cpanel/scripts/rebuildhttpdconf',
        args    => [],
    );

    if ( $run->CHILD_ERROR() ) {
        my $out = $run->stdout() . $run->stderr();
        warn "Failed to rebuild apache configuration:  $out\n";
    }

    Cpanel::HttpUtils::ApRestart::BgSafe::restart();
    return;
}

1;
